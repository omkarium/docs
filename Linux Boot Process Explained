Agenda: As I am on my way to build LFS (Linux From Scratch)/(Own Custom Linux operating system), having this knowledge is important. This is just a write up just to strengthen my existing knowledge. I could be wrong about some points. 
(Talking to my future self) Hey! Let me know if I am wrong anywhere and correct this.

**Terminologies**
Firmware: Its a software which resides on all digital electronic chips which more or less work the hardware directly.
BIOS: BIOS is a firmware which resides on Motherboard EEPROM chip (a non volatile chip) which is the first program that executes after a system power's up
UEFI: This is also a firmware similar to BIOS. Not every Motherboard supports it. Most modern systems have BIOS and UEFI on chip as modes, and leave it to the user to decide which one to use to start the boot and this process is called "choosing the mode". The user can choose to boot either in BIOS mode or UEFI mode.
Kernel: A kernel is a modular piece of software running with the highest privileges on machine which is the core of an Operating system. Kernel's job is to manage, allocate, monitor processes, interacting with drivers/modules like loading and unloading, interacting directly with hardware and talking to apps on the user space.
Drivers: These are individual special programs which operates directly inside the Kernel and helps the kernel interact with the Hardware's firmware created for a specific device/hardware in mind. List of common drivers are, File system drivers (to support ext2, ntfs, ext4, brtfs etc), Display drivers, Audio drivers, Bluetooth drivers, Keyboard drivers, Network drivers, Printer drivers etc
Bootloader: It's the software which boots the operating system and it is responsible for loading the Kernel in to Memory. The Stage 2 Bootloaders resides in /boot directory of the root of fs. The Stage 1 Bootloaders are installed on to the boot sector such as MBR or GPT. Stage 2 Bootloader aka the real Bootloader is called by the Stage 1 Bootloader. This process is called "Chaining". Popular bootloaders are Grub, Grub2, Syslinux, Brug, Lilo etc.
MBR: Aka the Master Boot Record is first few hundred bytes (512 bytes) of a configured Hard drive. It's a reserve space at the beginning of the drive which contains how the partitions on the drive are organised. It also contains the Stage 1 Bootloader. It is also referred as a "Partition Table/Partition Scheme" as it holds the start and end sectors of each partition and other critical metadata of the said partitions.
GPT: GUID Partition table is a modern replacement of the MBR partition scheme. Unlike MBR which holds all the partition metadata in the beginning bytes/sector of the drive which is considered bad because in situations where this first sector gets corrupted, the user could potentially lose either none, some or all the data even though the data is virtually still there, because the BIOS/UEFI would not be able to tell from which starting and ending sectors the boot partition and the root partition exist, to boot or mount, and it gets hard to retrieve the data without this metadata, but in case of the GPT, the GPT holds the partition metadata by distributing them in the end sectors of all the existing partition. It also does data integrity checks periodically. If the first Partition which is typically the boot partition somehow gets corrupted, there is still scope to boot and save the data because of the redundancy/mirroring mechanism GPT follows. GPT also has a version of the MBR called a "Protective MBR" which is useful when the user is booting legacy operating system which only recognises the MBR partion scheme and not consider GPT as alien.
Typically, BIOS recognises MBR and UEFI recognises both MBR and GPT, but the user is recommended to go with the compatible partition scheme for the right firmware. UEFI chooses to work with GPT for compatibility.
InitRamfs/Initrd: InitRamfs short form for "Initial RAM file system" is a simple and minimalist file system which is the evolved version of the old Initrd aka the "Initial RAM disk". It's purpose is to simplify complicated tasks during the kernel boot process which the kernel directly cannot do. The InitRamfs mounts the real root file system aka "/" through "Init". 
CPIO: Copy Input and Output is a archive file format. The InitRamfs is deployed using this file format.
Operating System: It's a suite of applications, drivers, and the kernel all combinedly working together and being referred as a single unit.
File system: It can be many things depending on the context and who is naming it. In one context it is referring to the /usr, /root, /sys, /bin, /proc etc locations on the disk. In another context it is talking about the Partition type/format such as ext4, btrfs, zfs etc. Note: GPT and MBR are not filesystems, partitions or partition types. They are called "Partition schemes". 

The boot process simplified 
1. When the user powers the machine, let it be whatever the underlying architecture is (x86, arm), the EEPROM chip containing the BIOS or the UEFI firmware loads it into the memory (RAM) directly and tells the CPU to set instruction pointer to the beginning of the firmware program and start executing. 
2. Now this firmware contains the instructions telling the CPU how to talk to the Harddrive, but before doing that it also has instructions to do some Initial checks such as detecting devices and see whether all the devices are active, properly setup without any issues. If the firmware sees any problem which any devices, such as no power to HD etc, it simply exits. The firmware gathers all the information about the devices which are attached to the motherboard. It is programmed to look for the "bootable devices" in sequence. In BIOS the user can choose the order of these devices. For example, sometimes the user would like to boot from the bootable USB stick and if the stick is not present then it looks for CD, DVD, and finally the HD. Once the bootable device is detected and set, the firmware always looks into the first sector/boot sector which is also known as MBR. The MBR is not a file system but is a tiny file represented as a sequence of bytes, 512 to be exact. It does not hold the complete bootloader within itself but it contains what the BIOS/UEFI calls a "boot signature". This signature is a special format (DOS) which contains the initial boot code (stage1) which points to a second stage boot code aka the main bootloader which resides in the root / (aka root partition), whereever it is on the Harddrive, and the partition table data. So MBR contains the stage1 boot loader (440 bytes) and the partition table data (72 bytes) in the exact sequence. Interestingly, the user can also choose to put the root partition not at the first sectors of the HD, but at the last sector as well. This proves that main bootloader doesn't necessarily have to be placed in the first parition of the bootable device (HD).  The firmware instructs the cpu to copy the MBR which is on the first sector of the HD onto the RAM, because firmware always decide to look at this first sector no matter what (hard coded) and sets the IP to start the cpu executing from there onwards.
3. The MBR contains the Stage 1 Bootloader code (which helps to locate the stage 2 boot loader on the disk) and partition information, and when the cpu executes the stage1, the IP jumps to the Stage 2 main bootloader which is residing in the /boot directory. Interestingly the Kernel code or img is also located in the same /boot location. So, the control goes to the main bootloader say Grub, and Grub starts executing it's code. The Grub has what is known as configuration file /boot/grub2/grub.cfg and also default configuration files /etc/default/grub. This is a file which contains what are the kernels/operating systems installated on the disk. The user is presented options to choose which kernel/os to load into memory and handover the execution control.
4. Say you have Windows and Linux dual booted on your machine and you choose to go with the Linux Mint os on Grub menu. Then the Linux kernel which is located in /boot is loaded into the memory and the control is handed over to it and Grub's work is complete. The bootloader also loads something called the InitiRamfs or InitRd alongside the kernel and more on that later.
5. The Linux kernel which starts its execution which is also confusingly called as the "Kernel boot process" or the "boot process". Now comes the strange and the important part. 
6. The Linux kernel is modular by nature and it build by the developer in such a way that it is lightweight and generic. This means that Linus Torvald doesn't intend to shop all the possible drivers specific to all possible devices in the world and ship them along with the kernel. Only the bare essentials default drivers are provided within the kernel package/image. All the essential drivers let it be hardware or software drivers are to be provided by the maintainers of a linux distribution. If a certain linux distribution does not provide the drivers, then certain programs cannot work and certain hardware cannot be accessed. And this is why if we remember, back in the golden days of Windows 7, people had to download the drivers from the homepage of the Laptop/Desktop manufacturers like Dell or HP. So hardware drivers are mostly provides by the manufacturer for specific operating system and chipset architecture in mind, whereas software drivers are provided by the Os/distributions like Windows, Ubuntu, Linux Mint, Fedora etc. Now a days even the hardware drivers are provided by these Open source Distributions.
So, basically in Linux case the Distro provides majority of the device drivers, either hardware or software. These drives are to packaged into what we call the InitRamfs CPIO archive file.
The job of the InitRamfs or InitRd is to do those things which the Linux kernel cannot by itself. This is where things get a bit messy to understand. But first we should ask "what exactly cannot the Linux kernel do by itself?" And, "Is this InitRamfs" mandatory for the system fully bootup?
First, to answer the first question we must ask another question, "what does the Linux kernel do?". It's simple. The kernel mounts the root file system aka / for the userspace to exist and also loads and unloads drivers dynamically as modules during the runtime of the os. The Userspace is the imaginary space where all the apps or programs which the users run. Now, we can ask another question, "Why can't the kernel load all the modules statically during the boot process itself instead of doing it during the userspace runtime?" The answer to that is, "Bloat". If we do that, the kernel gets bloated heavily and moreover the kernel should be dedicated programmed in that way to load it's drivers directly from within. Luckily, that's not the Linux kernel operates. Secondly, it is totally a waste of memory to load all the modules into kernel and keep it like that all the time simply because not all programs the user is currently running require all the driver modules. I may choose to not use the audio, and network drivers today, so why to load them during boot? We might simply think we should unload them if not in use after boot. But there lies the egg and chicken problem. The kernel having modules built-in cannot unload the modules itself because the modules are part of itself. You cannot instruct to unload something which is a part of you and still expect to be working. The kernel once loaded into the memory having the modules also within in the same memory cannot ask the cpu to unload the modules memory without risking unloading itself. Just think. How can you ask the cpu to delete some memory while you are the one who is holding on to the memory. It's not possible. Infact, the same logic applies for loading the modules too. If the kernel has built-in modules, how can it extract and load parts of itself. This is like asking a compiled exe program to extract or load json or text resource files contained within itself dynamically and start working on it. It's called "being reflexive" and it's highly complicated to achieve, even in dumb and verbose languages like Java. If we still insist having built-in modules and risk them having in memory throughout the lifetime of the os execution, then we have to ask the bootloader to do that job (which is not it's job), or create a custom linux kernel code to statically link the modules and so there won't be the concept of loading and unloading at all. 
Now, let's ask the second question again. Is the InitRamfs mandatory? No. It's not. Part of the job of the InitRamfs is to mount the filesystem and handover the control to the Init process called the PID1. All userspace processes spawn off from PID1 as their parent or grandfather. But the Linux kernel can also directly mount and unmount the rootfs, but the challenge it has is to call onto the file system command such as mount, umount. So, the kernel must also come with such app binaries as well if we want to do it that way. Interestingly, there are people who do such things and achieved it. These are the people who has really good knowledge on the kernel working and customising it. But still, even with good knowledge there are stuff even more hard to achieve. Such a mounting an encrypted rootfs etc. 
7. Here comes InitRamfs to save the day. The name says it all. It is the initial file system on loaded onto the memory. The fs contains some essential app binaries, something similar to what you can find in /bin, /usr/bin, or busybox. The InitRamfs typically created by specific distribution company m, is served as a CPIO file and it is loaded into the memory simulataneosly by the Bootloader Grub while it is also loading the kernel into memory. The kernel starts using the driver modules from this fs through the execution of the userspace by staying active and uses the "mount" app binary to mount the rootfs. The kernel then executes the "init" script in the Ramfs as PID1 using exec() and fork(), therefore marking the beginning of the userspace and it later hands over a pseudo control to the systemd (which is also referred as the "Real init")

So to summarise the whole boot working flow
1. EEPROM chip loads BIOS or UEFI to memory.
2. The BIOS or the UEFI probes for bootable devices calls to load the MBR or GPT into memory. The MBR or GPT has a Stage 1 Bootloader installed like Grub. The Stage 1 Bootloader finds the main Stage 2 Bootloader on disk using the boot signature and the partition table information and executes it.
3. Grub the stage 2 Bootloader looks at its cfg file and asks the user to choose the os if the machine is dual booted or it defaults to one os.
4. The Grub loads the kernel and InitRamfs and hands over the control to the kernel, and completes. The kernel unloads the Grub from memory.
5. The kernel using the Init script of the InitRamfs fs starts the init process as PID 1 and won't die until the user power off the system.

